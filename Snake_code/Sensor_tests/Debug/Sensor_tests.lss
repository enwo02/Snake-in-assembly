
AVRASM ver. 2.2.8  C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm Sun May 29 19:01:29 2022

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m128def.inc'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(4): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(5): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\definitions.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(30): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\lcd.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(31): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\printf.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(32): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\my_macros.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(33): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\matrix_driver.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(35): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\snake_logic.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(36): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\eeprom.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m128def.inc'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(4): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(5): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\definitions.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(30): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\lcd.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(31): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\printf.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(32): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\my_macros.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(33): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\matrix_driver.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(35): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\snake_logic.asm'
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(36): Including file 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\eeprom.asm'
                                 
                                 ; file	timer_ov.asm   target ATmega128L-4MHz-STK300
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; purpose timers 0,1,2 overflows	
                                 
                                 .include "macros.asm"		; include macro definitions
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.01 20180820 AxS
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	push	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 .include "definitions.asm"	; include register/constant definitions
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 
                                 ;note: b0: ir_ready // button_ready // data_ready // toggle_mode
                                 
                                 ; === interrupt vector table ===
                                 .org	0
000000 c48b                      	rjmp		reset
                                 .org			INT0addr		;reset button
000002 940c 03d7                 	jmp			ext_int0
                                 .org			INT1addr		;toggle button
000004 940c 03dd                 	jmp			ext_int1		
                                 .org			INT2addr		;speed up button
000006 940c 03ec                 	jmp			ext_int2		
                                 .org			INT3addr		;slow down button
000008 940c 0423                 	jmp			ext_int3		
                                 .org			INT7addr		;IR remote interrupt
000010 940c 0464                 	jmp			ext_int7
                                 .org			OC0addr			;snake turn timer
00001e c45a                      	rjmp		output_compare0
                                 .org			OVF2addr		;measure timer
000014 c45e                      	rjmp		overflow2
                                 .org 			ADCCaddr		;AC/DC converter
00002a c45f                      	rjmp		ADCCaddr_sra
                                 
                                 
                                 .include "lcd.asm"
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
00002b 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
00002d fc37
00002e cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
00002f d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000030 9300 8000                 	sts	LCD_IR, w		; store w in IR
000032 9508                      	ret
                                 	
                                 lcd_4us:
000033 d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
000034 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
000035 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
000036 302d
000037 f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
000038 302a
000039 f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
00003a 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
00003c fd07
00003d cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
00003e dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
00003f 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
000041 9508                      	ret	
                                 	
000042 e001
000043 cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
000044 e002
000045 cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
000046 e100
000047 cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
000048 e104
000049 cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
00004a e108
00004b cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
00004c e10c
00004d cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
00004e e00d
00004f cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
000050 e00c
000051 cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
000052 e00e
000053 cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
000054 e00c
000055 cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
000056 b705                      	in	w,MCUCR					; enable access to ext. SRAM
000057 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
000058 bf05                      	out	MCUCR,w
000059 e001
00005a dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
00005b e006
00005c dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
00005d e00c
00005e dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
00005f e308
000060 dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
000061 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
000062 2f02                      	mov	w,a0
000063 6800                      	ori	w,0b10000000
000064 cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
000065 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
000067 fd07
000068 cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
000069 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
00006a 6800                      	ori	w,0b10000000		; write address command
00006b dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
00006c 9300 8000                 	sts	LCD_IR,w			; store in IR
00006e 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
00006f 932f                      	push	a0				; safeguard a0
000070 e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
000071 dff0                      	rcall	LCD_pos			; set cursor position
000072 912f                      	pop	a0					; restore a0
                                 .include "printf.asm"
000073 9508                      
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.02 20180821 AxS supports SRAM input from 0x0260
                                 ;					through 0x02ff that should be reserved
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 ;	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having their bit7 set to 1.
                                 ;
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; that determines the origin of variables that must be printed (if any)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	0x0260..0x02ff	SRAM
                                 ; Variables can be located into register and I/0s, and can also
                                 ; be stored into data SRAM at locations 0x0200 through 0x02ff. Any
                                 ; sram address higher than 0x0060 is assumed to be at (0x0260+address)
                                 ; from automatic address detection in _printf_formatted: and subsequent
                                 ; assignment to xh; xl keeps its value. Consequently, variables that are
                                 ; to be stored into SRAM and further printed by fprint must reside at
                                 ; 0x0200 up to 0x02ff, and must be addressed using a label. Usage: see
                                 ; file string1.asm, for example.
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
000074 91ff
000075 91ef                      	POPZ			; z points to begin of "string"
000076 0fee
000077 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
000078 93af
000079 93bf                      	PUSHX
                                 		
                                 _printf_read:
00007a 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
00007b 9631                      	adiw	zl,1	; increment pointer Z
00007c 2000                      	tst	r0			; test for ZERO (=end of string)
00007d f021                      	breq	_printf_end	; char=0 indicates end of ascii string
00007e f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
00007f 2d00                      	mov	w,r0
000080 d017                      	rcall	_putw	; display the character
000081 cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
000082 9631                      	adiw	zl,1	; point to the next character
000083 95f6
000084 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
000085 91bf
000086 91af                      	POPX
000087 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
000088 fa00                      	bst	r0,0		; store sign in T
000089 2d00                      	mov	w,r0		; store formatting character in w
00008a 95c8                      	lpm	
00008b 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
00008c 36a0                      	cpi	xl,0x60
00008d f010                      	brlo rio_space
                                 dataram_space:		; variable originates from SRAM memory
00008e e0b2                      	ldi	xh,0x02		;>addresses are limited to 0x0260 through 0x02ff
00008f c001                      	rjmp space_detect_end	;>that enables automatic detection of the origin
                                 rio_space:			; variable originates from reg or I/O space 
000090 27bb                      	clr	xh			; clear high-byte, addresses are 0x0000 through 0x003f (0x005f)
                                 space_detect_end:
000091 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
000092 3804
000093 f079                      	JK	w,FCHAR,_putchar
000094 3805
000095 f081                      	JK	w,FSTR ,_putstr
000096 c015                      	rjmp	_putnum
                                 	
000097 cfe2                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
000098 932f
000099 93ff
00009a 93ef                      	PUSH3	a0,zh,zl
00009b 2de4
00009c 2df5
00009d 2f20                      	MOV3	a0,zh,zl, w,e1,e0
00009e 9509                      	icall			; indirect call to "putc"
00009f 91ef
0000a0 91ff
0000a1 912f                      	POP3	a0,zh,zl
0000a2 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
0000a3 910c                      	ld	w,x
0000a4 dff3                      	rcall	_putw
0000a5 cfd4                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
0000a6 910d                      	ld	w,x+
0000a7 2300                      	tst	w
0000a8 f409                      	brne	PC+2
0000a9 cfd0                      	rjmp	_printf_read
0000aa dfed                      	rcall	_putw
0000ab cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
0000ac 935f
0000ad 934f
0000ae 933f
0000af 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
0000b0 939f
0000b1 938f
0000b2 937f
0000b3 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
0000b4 912d
0000b5 913d
0000b6 914d
0000b7 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
0000b8 fd06
0000b9 c006                      	JB1	w,6,_putdec
0000ba fd05
0000bb c00f                      	JB1	w,5,_putbin
0000bc fd04
0000bd c010                      	JB1	w,4,_puthex
0000be fd03
0000bf c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
0000c0 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
0000c1 2f70                      	mov	b1,w
0000c2 9576                      	lsr	b1
0000c3 7077                      	andi	b1,0b111	
0000c4 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0000c5 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
0000c6 2f90                      	mov	b3,w
0000c7 9592                      	swap	b3
0000c8 7093                      	andi	b3,0b11
0000c9 9593                      	inc	b3			; b3 = number of bytes (1..4)
0000ca c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
0000cb e062                      	ldi	b0,2		; b0 = base (2)
0000cc e094                      	ldi	b3,4		; b3 = number of bytes (4)	
0000cd c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
0000ce e160                      	ldi	b0,16		; b0 = base (16)
0000cf e094                      	ldi	b3,4		; b3 = number of bytes (4)
0000d0 c000                      	rjmp	_getdig
                                 
                                 _getdig:
0000d1 2f70                      	mov	b1,w
0000d2 9576                      	lsr	b1
0000d3 7077                      	andi	b1,0b111
0000d4 f409                      	brne	PC+2
0000d5 e078                      	ldi	b1,8		; if b1=0 then 8-digits
0000d6 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0000d7 e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
0000d8 c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
0000d9 e06a                      	ldi	b0,10		; base=10	
0000da 95c8                      	lpm
0000db 2d80                      	mov	b2,r0		; load dec.point position
0000dc 9631                      	adiw	zl,1	; increment char pointer
0000dd 95c8                      	lpm
0000de 2d70                      	mov	b1,r0		; load ii.ff format
0000df 9631                      	adiw	zl,1	; increment char pointer
                                 	
0000e0 2f90                      	mov	b3,w
0000e1 9595                      	asr	b3
0000e2 7093                      	andi	b3,0b11
0000e3 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
0000e4 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
0000e5 3094
0000e6 f081                      	JK	b3,4,_printf_4b
0000e7 3093
0000e8 f051                      	JK	b3,3,_printf_3b
0000e9 3092
0000ea f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
0000eb 2733                      	clr	a1
0000ec f416                      	brtc	PC+3	; T=1 sign extension
0000ed fd27                      	sbrc	a0,7
0000ee ef3f                      	ldi	a1,0xff
                                 _printf_2b:
0000ef 2744                      	clr	a2
0000f0 f416                      	brtc	PC+3	; T=1 sign extension	
0000f1 fd37                      	sbrc	a1,7
0000f2 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
0000f3 2755                      	clr	a3
0000f4 f416                      	brtc	PC+3	; T=1 sign extension
0000f5 fd47                      	sbrc	a2,7
0000f6 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
0000f7 d009                      	rcall	_ftoa		; float to ascii
0000f8 916f
0000f9 917f
0000fa 918f
0000fb 919f                      	POP4	b3,b2,b1,b0	; restore b
0000fc 912f
0000fd 913f
0000fe 914f
0000ff 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
000100 cf79                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
000101 92cf                      	push	d0
000102 92bf
000103 92af
000104 929f
000105 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
000106 18bb
000107 24aa
000108 2499
000109 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
00010a f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
00010b 94e8                      	clt
00010c 2355                      	tst	a3				; if MSb(a)=1 then a=-a
00010d f46a                      	brpl	_ftoa_plus
00010e 9468                      	set					; T=1 (minus)
00010f 2377                      	tst	b1
000110 f009                      	breq	PC+2		; if b1=0 the print ALL digits
000111 5170                      	subi	b1,0x10		; decrease int digits
000112 9550
000113 9540
000114 9530
000115 9520
000116 ef0f
000117 1b20
000118 0b30
000119 0b40
00011a 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
00011b 2388                      	tst	b2				; b0=0 (only integer part)
00011c f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
00011d 9555
00011e 9547
00011f 9537
000120 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000121 94b7
000122 94a7
000123 9497
000124 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
000125 958a
000126 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
000127 937f                      	push	b1			; ii.ff (ii=int digits)
000128 9572                      	swap	b1
000129 707f                      	andi	b1,0x0f
                                 	
00012a e20e                      	ldi	w,'.'			; push decimal point
00012b 930f                      	push	w
                                 _ftoa_int1:
00012c d045                      	rcall	_div41		; int=int/10
00012d 2d0c                      	mov	w,d0			; d=reminder
00012e d030                      	rcall	_hex2asc
00012f 930f                      	push	w			; push rem(int/10)
000130 2700
000131 1720
000132 0730
000133 0740
000134 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
000135 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
000136 2377                      	tst	b1
000137 f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
000138 957a
000139 f791                      	DJNZ	b1,_ftoa_int1
00013a c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
00013b 2377                      	tst	b1				; if b1=0 then print ALL int-digits
00013c f029                      	breq	_ftoa_sign
00013d 957a                      	dec	b1
00013e f019                      	breq	_ftoa_sign
00013f e200                      	ldi	w,' '			; write spaces
000140 df57                      	rcall	_putw	
000141 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
000142 f416                      	brtc	PC+3		; if T=1 then write 'minus'
000143 e20d                      	ldi	w,'-'
000144 df53                      	rcall	_putw
                                 _ftoa_int3:
000145 910f                      	pop	w
000146 320e                      	cpi	w,'.'
000147 f011                      	breq	PC+3
000148 df4f                      	rcall	_putw
000149 cffb                      	rjmp	_ftoa_int3
                                 
00014a 917f                      	pop	b1				; ii.ff (ff=frac digits)
00014b 707f                      	andi	b1,0x0f
00014c 2377                      	tst	b1
00014d f059                      	breq	_ftoa_end
                                 _ftoa_point:	
00014e df49                      	rcall	_putw		; write decimal point
00014f 2d28
000150 2d39
000151 2d4a
000152 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
000153 d011                      	rcall	_mul41		; d.frac=10*frac
000154 2d0c                      	mov	w,d0
000155 d009                      	rcall	_hex2asc
000156 df41                      	rcall	_putw
000157 957a
000158 f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
000159 908f
00015a 909f
00015b 90af
00015c 90bf                      	POP4	c3,c2,c1,c0
00015d 90cf                      	pop	d0
00015e 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
00015f 300a                      	cpi	w,10
000160 f410                      	brsh	PC+3
000161 5d00                      	addi	w,'0'
000162 9508                      	ret
000163 5a09                      	addi	w,('a'-10)
000164 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
000165 24cc                      _mul41:	clr	d0			; clear byte4 of result
000166 e200                      	ldi	w,32			; load bit counter
000167 9488                      __m41:	clc				; clear carry
000168 fd20                      	sbrc	a0,0		; skip addition if LSB=0
000169 0ec6                      	add	d0,b0			; add b to MSB of a
00016a 94c7
00016b 9557
00016c 9547
00016d 9537
00016e 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
00016f 950a
000170 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
000171 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
000172 24cc                      _div41:	clr	d0			; d will contain the remainder
000173 e200                      	ldi	w,32			; load bit counter
000174 1f22
000175 1f33
000176 1f44
000177 1f55
000178 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
000179 1ac6                      	sub	d0, b0			; subtract b from remainder
00017a f408                      	brcc	PC+2	
00017b 0ec6                      	add	d0, b0			; restore if remainder became negative
00017c 950a
00017d f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
00017e 1f22
00017f 1f33
000180 1f44
000181 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
000182 9550
000183 9540
000184 9530
000185 9520                      	COM4	a3,a2,a1,a0	; complement result
000186 9508                      	ret
                                 .include "my_macros.asm"
                                 
                                  * my_macros.asm
                                  *
                                  *  Created: 03/05/2022 20:59:05
                                  *   Author: eliow
                                  */
                                 
                                  ;Stores immediate RGB values into z register
                                  .macro load_led_value_i
                                 	ldi	w, @1	; pixel 1 [GRB]
                                 	st	z+,w
                                 	ldi w, @0
                                 	st	z+,w
                                 	ldi	w, @2
                                 	st z+,w
                                 .endmacro
                                 
                                 ;Stores RGB values from register into z register
                                  .macro load_led_value
                                 	st	z+,@1	; pixel 1 [GRB]
                                 	st	z+,@0
                                 	st	z+,@2
                                 .endmacro
                                 
                                 ;finds position for new snake head from dirBits (@1) & current snake (@0)
                                 ;stores result in w
                                 .macro findNewHeadPosition
                                 	mov		w, @0	;copy current Head in w
                                 	cpi		@1, 0	;see if direction = 0 --> plusX
                                 	breq	plusX
                                 	cpi		@1, 1	;see if direction = 1 --> plusY
                                 	breq	plusY
                                 	cpi		@1, 2	;see if direction = 2 --> minusX
                                 	breq	minusX
                                 	cpi		@1, 3	;see if direction = 3 --> minusY
                                 	breq	m_minusY
                                 	rjmp	error_case
                                 
                                 m_minusY:
                                 	jmp minusY
                                 
                                 plusX:
                                 	;move in +x
                                 	dec		w		;when not on right border
                                 	CPI8	w, 0xff,7,15,23,31,39,47,55
                                 	brne	PC + 2
                                 	ADDI	w, 8	;rewind when on the right border
                                 	rjmp	finishHeadFinding
                                 plusY:
                                 	;move in +y
                                 	ADDI	w, 8	;when not on top border
                                 	CPI8	w, 64,65,66,67,68,69,70,71
                                 	brne	PC + 2
                                 	subi	w, 64	;rewind when on the top border
                                 	rjmp	finishHeadFinding
                                 minusX:
                                 	;move in -x
                                 	inc		w		;when not on left border
                                 	CPI8	w, 8,16,24,32,40,48,56,64
                                 	brne	PC + 2
                                 	subi	w, 8	;rewind when on the left border
                                 	rjmp	finishHeadFinding
                                 
                                 minusY:
                                 	;move in -y
                                 	subi	w, 8	;when not on bottom border
                                 	CPI8	w, 0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8
                                 	brne	PC + 2
                                 	ADDI	w, 64	;rewind when on the bottom border
                                 	rjmp	finishHeadFinding
                                 
                                 error_case:
                                 	;This should never happen (if dirBit >3)
                                 finishHeadFinding:
                                 	;yey the head is succesfully found :D
                                 .endmacro
                                 
                                 ;checks if first value is equal to one of the following 8
                                 .macro CPI8
                                 	mov		a1, @0
                                 
                                 	cpi		a1, @1
                                 	breq	CPI8_end
                                 	cpi		a1, @2
                                 	breq	CPI8_end
                                 	cpi		a1, @3
                                 	breq	CPI8_end
                                 	cpi		a1, @4
                                 	breq	CPI8_end
                                 	cpi		a1, @5
                                 	breq	CPI8_end
                                 	cpi		a1, @6
                                 	breq	CPI8_end
                                 	cpi		a1, @7
                                 	breq	CPI8_end
                                 	cpi		a1, @8
                                 	breq	CPI8_end
                                 CPI8_end:
                                 	
                                 .endmacro
                                 
                                 .macro checkSelfEating
                                 	ldi		xl,low(0x04C2)		;where Snake is
                                 	ldi		xh,high(0x04C2)
                                 	ld		w, x+				;load in head
                                 checkSelfEating_loop:
                                 	ld		a2, x+
                                 	cp		w, a2
                                 	breq	checkSelfEating_game_over	;if head somewhere where snake already is --> game over
                                 	cpi		a2, 0xff
                                 	brne	checkSelfEating_loop		;loop until 0xff found
                                 
                                 	ldi		xl,low(0x04C2)				;reset x pointer
                                 	ldi		xh,high(0x04C2)
                                 	rjmp	checkSelfEating_end
                                 
                                 checkSelfEating_game_over:
                                 	rcall	game_over
                                 checkSelfEating_end:
                                 .endmacro
                                 
                                 .macro loadSnakeLength
                                 	ldi		xl,low(0x04C1)		;where Snake is
                                 	ldi		xh,high(0x04C1)
                                 	clr		b3					;set length to zero
                                 loadSnakeLength_loop:
                                 	ld		w, x+
                                 	cpi		w, 0xff				;check if at end of snake
                                 	breq	loadSnakeLength_end
                                 	inc		b3					;add one for every snake part found
                                 	rjmp	loadSnakeLength_loop
                                 loadSnakeLength_end:
                                 	dec		b3					;adjust, because it adds before checking
                                 .endmacro
                                 
                                  .macro IFAND	; r1, b1, r2, b2  sets clear if ether bits are '0'
                                 	sbrs		@0, @1
                                 	sec
                                 	sbrs		@2, @3
                                 	sec
                                 .endmacro
                                 
                                 .macro CPI2		;cpi on 2 bytes
                                 	push		_w
                                 	ldi			w,high(@2)
                                 	ldi			_w,low(@2)
                                 	CP2			@0, @1, w, _w
                                 	pop			_w
                                 .endmacro
                                 
                                 .macro INC_LIM10		;reg,lim	;incremente de 5 avec une limite
                                 	INC_LIM		@0,@1
                                 	INC_LIM		@0,@1
                                 	INC_LIM		@0,@1
                                 	INC_LIM		@0,@1
                                 	INC_LIM		@0,@1
                                 	INC_LIM		@0,@1
                                 	INC_LIM		@0,@1
                                 	INC_LIM		@0,@1
                                 	INC_LIM		@0,@1
                                 	INC_LIM		@0,@1
                                 .endmacro
                                 
                                 .macro DEC_LIM10		;reg,lim	;dcremente de 5 avec une limite
                                 	DEC_LIM		@0,@1
                                 	DEC_LIM		@0,@1
                                 	DEC_LIM		@0,@1
                                 	DEC_LIM		@0,@1
                                 	DEC_LIM		@0,@1
                                 	DEC_LIM		@0,@1
                                 	DEC_LIM		@0,@1
                                 	DEC_LIM		@0,@1
                                 	DEC_LIM		@0,@1
                                 	DEC_LIM		@0,@1
                                 .include "matrix_driver.asm"
                                 
                                 ; purpose send data to ws2812b using 4 MHz MCU and standard I/O port
                                 ;         display and paralllel process (blinking LED0)
                                 ; usage: buttons on PORTD, ws2812 on PORTD (bit 1)
                                 ;        press button 0
                                 ;       a pattern is stored into memory and displayed on the array
                                 ;       LED0 blinks fast; when button0 is pressed and released, LED1
                                 ;       akcnowledges and the pattern displayed on the array moves by
                                 ;       one memory location
                                 ; warnings: 1/2 timings of pulses in the macros are sensitive
                                 ;			2/2 intensity of LEDs is high, thus keep intensities
                                 ;				within the range 0x00-0x0f, and do not look into
                                 ;				LEDs
                                 ; 20220315 AxS
                                 
                                 ;.include "macros.asm"		; include macro definitions
                                 ;.include "definitions.asm"	; include register/constant definitions
                                 
                                 ; WS2812b4_WR0	; macro ; arg: void; used: void
                                 ; purpose: write an active-high zero-pulse to PD1
                                 .macro	WS2812b4_WR0
                                 	clr u
                                 	sbi PORTD, 7
                                 	out PORTD, u
                                 	nop
                                 	nop
                                 	;nop	;deactivated on purpose of respecting timings
                                 	;nop
                                 .endm
                                 
                                 ; WS2812b4_WR1	; macro ; arg: void; used: void
                                 ; purpose: write an active-high one-pulse to PD1
                                 .macro	WS2812b4_WR1
                                 	sbi PORTD, 7
                                 	nop
                                 	nop
                                 	cbi PORTD, 7
                                 	;nop	;deactivated on purpose of respecting timings
                                 	;nop
                                 
                                 .endm
                                 
                                 
                                 ; ws2812b4_init		; arg: void; used: r16 (w)
                                 ; purpose: initialize AVR to support ws2812
                                 ws2812b4_init:
                                 	;OUTI	DDRD,0x02
000187 9508                      ret
                                 
                                 ; ws2812b4_byte3wr	; arg: a0,a1,a2 ; used: r16 (w)
                                 ; purpose: write contents of a0,a1,a2 (24 bit) into ws2812, 1 LED configuring
                                 ;     GBR color coding, LSB first
                                 ws2812b4_byte3wr:
                                 
000188 e008                      	ldi w,8
                                 ws2b3_starta0:
000189 fd27                      	sbrc a0,7
00018a c006                      	rjmp	ws2b3w1
00018b 2433
00018c 9a97
00018d ba32
00018e 0000
00018f 0000                      	WS2812b4_WR0			; write a zero
000190 c004                      	rjmp	ws2b3_nexta0
                                 ws2b3w1:
000191 9a97
000192 0000
000193 0000
000194 9897                      	WS2812b4_WR1
                                 ws2b3_nexta0:
000195 0f22                      	lsl a0
000196 950a                      	dec	w
000197 f789                      	brne ws2b3_starta0
                                 
000198 e008                      	ldi w,8
                                 ws2b3_starta1:
000199 fd37                      	sbrc a1,7
00019a c006                      	rjmp	ws2b3w1a1
00019b 2433
00019c 9a97
00019d ba32
00019e 0000
00019f 0000                      	WS2812b4_WR0			; write a zero
0001a0 c004                      	rjmp	ws2b3_nexta1
                                 ws2b3w1a1:
0001a1 9a97
0001a2 0000
0001a3 0000
0001a4 9897                      	WS2812b4_WR1
                                 ws2b3_nexta1:
0001a5 0f33                      	lsl a1
0001a6 950a                      	dec	w
0001a7 f789                      	brne ws2b3_starta1
                                 
0001a8 e008                      	ldi w,8
                                 ws2b3_starta2:
0001a9 fd47                      	sbrc a2,7
0001aa c006                      	rjmp	ws2b3w1a2
0001ab 2433
0001ac 9a97
0001ad ba32
0001ae 0000
0001af 0000                      	WS2812b4_WR0			; write a zero
0001b0 c004                      	rjmp	ws2b3_nexta2
                                 ws2b3w1a2:
0001b1 9a97
0001b2 0000
0001b3 0000
0001b4 9897                      	WS2812b4_WR1
                                 ws2b3_nexta2:
0001b5 0f44                      	lsl a2
0001b6 950a                      	dec	w
0001b7 f789                      	brne ws2b3_starta2
                                 	
0001b8 9508                      ret
                                 
                                 ; ws2812b4_reset	; arg: void; used: r16 (w)
                                 ; purpose: reset pulse, configuration becomes effective
                                 ws2812b4_reset:
0001b9 9897                      	cbi PORTD, 7
0001ba e401
0001bb 2e30
0001bc e001
0001bd 943a
0001be f7f1
0001bf 943a
0001c0 950a
0001c1 f7d9                      	WAIT_US	50 	; 50 us are required, NO smaller works
                                 .include "input_drivers.asm"	;distance sensor and IR sensor drivers
0001c2 9508                      
                                  * sensor_routines.asm
                                  *
                                  *  Created: 27/05/2022 16:53:24
                                  *   Author: Hp
                                  */ 
                                 
                                  ; DISTANCE SENSOR
                                 
                                  measure:	
                                 
0001c3 9a36                      	sbi			ADCSR,ADSC			; AD start conversion
                                 	
0001c4 b0c4                      	in			d0,ADCL				; read low byte first
0001c5 b0d5                      	in			d1,ADCH				; read high byte second
                                 
0001c6 7f5e                      	cbr			a3,ADC_RDY_BIT		;Wait until next ADC data ready
                                 	
0001c7 9508                      	ret
                                 
                                  change_dir:
0001c8 9ac3                      	sbi			PORTB,3
0001c9 9ac4                      	sbi			PORTB,4
0001ca 9ac5                      	sbi			PORTB,5
0001cb 9ac6                      	sbi			PORTB,6
0001cc 9ac7                      	sbi			PORTB,7
0001cd 2f16                      	mov			_w, b0
                                 	
0001ce 931f
0001cf e000
0001d0 e710
0001d1 16c1
0001d2 06d0
0001d3 911f                      	CPI2		d1, d0, TOO_FAR_VAL		; straight as default
0001d4 f070                      	brlo		led_4
0001d5 931f
0001d6 e001
0001d7 e910
0001d8 16c1
0001d9 06d0
0001da 911f                      	CPI2		d1, d0, TURN_L_VAL		; left turn
0001db f068                      	brlo		led_3
0001dc 931f
0001dd e003
0001de e210
0001df 16c1
0001e0 06d0
0001e1 911f                      	CPI2		d1, d0, TURN_R_VAL		; right turn
0001e2 f410                      	brsh		led_5
                                 	;show position on LED's
                                 	led_4:
0001e3 98c5                      	cbi			PORTB,5
0001e4 c007                      	rjmp		end_check
                                 	led_5:
0001e5 98c7                      	cbi			PORTB,7
0001e6 98c6                      	cbi			PORTB,6
0001e7 5f1f                      	ADDI		_w,1
0001e8 c003                      	rjmp		end_check
                                 	led_3:
0001e9 98c3                      	cbi			PORTB,3
0001ea 98c4                      	cbi			PORTB,4
0001eb 5011                      	subi		_w, 1
                                 	
                                 	end_check:
0001ec 2766                      	clr			b0
0001ed 7013                      	ANDI		_w, 0b11
0001ee 0f61                      	add			b0, _w		;sets the new direction
0001ef 9508                      	ret
                                 
                                 ; IR REMOTE
                                 
                                 prep:	
0001f0 932f
0001f1 933f
0001f2 934f
0001f3 935f                      	PUSH4		a0, a1, a2, a3
0001f4 92cf
0001f5 92df
0001f6 92ef
0001f7 92ff                      	PUSH4		d0, d1, d2, d3
                                 
0001f8 1b55
0001f9 2744                      	CLR2		a3,a2			; clear 2-byte register
0001fa 1b33
0001fb 2722                      	CLR2		a1,a0
0001fc e110                      	ldi			_w,16			; load bit-counter
                                 	
                                 addr: 
0001fd 990f
0001fe 9408
0001ff 9b0f
000200 9488                      	P2C			PINE,IR			; move Pin to Carry (P2C, 4 cycles)
000201 1f44
000202 1f55                      	ROL2		a3,a2			; roll carry into 2-byte reg (ROL2, 2 cycles)
000203 fd40                      	sbrc		a2,0			; (branch not taken, 1 cycle; taken 2 cycles)
000204 c00c                      	rjmp		rdz_a			; (rjmp, 2 cycles)
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm(221): warning: float->int cast, truncated
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm(70): macro 'WAIT_US' called here
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm' included form here
000205 e10e
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm(223): warning: float->int cast, truncated
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm(70): macro 'WAIT_US' called here
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm' included form here
000206 2e30
000207 e007
000208 943a
000209 f7f1
00020a 943a
00020b 950a
00020c f7d9                      	WAIT_US		(T1 - 4.5)
00020d 951a
00020e f771                      	DJNZ		_w,addr			; Decrement and Jump if Not Zero (true, 2 cycles; false, 1 cycle)
00020f 940c 021b                 	jmp			next_a			; (jmp, 3 cycles)
                                 
                                 rdz_a:							; read a zero
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm(221): warning: float->int cast, truncated
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm(75): macro 'WAIT_US' called here
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm' included form here
000211 e402
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm(223): warning: float->int cast, truncated
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm(75): macro 'WAIT_US' called here
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm' included form here
000212 2e30
000213 e00d
000214 943a
000215 f7f1
000216 943a
000217 950a
000218 f7d9                      	WAIT_US		(2*T1 - 5.5)
000219 951a
00021a f711                      	DJNZ		_w,addr			; Decrement and Jump if Not Zero
                                 
                                 next_a: 
00021b 2ec4
00021c 2ed5                      	MOV2	d1,d0, a3, a2	; store current address
00021d 2f24
00021e 2f35                      	MOV2		a1,a0,a3,a2
00021f e110                      	ldi			_w,16			; load bit-counter
000220 9488                      	clc
000221 1b55
000222 2744                      	CLR2	a3,a2
                                 
                                 data: 
000223 990f
000224 9408
000225 9b0f
000226 9488                      	P2C		PINE,IR			
000227 1f44
000228 1f55                      	ROL2		a3,a2			
000229 fd40                      	sbrc		a2,0			
00022a c00c                      	rjmp		rdz_d			
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm(221): warning: float->int cast, truncated
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm(90): macro 'WAIT_US' called here
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm' included form here
00022b e10e
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm(223): warning: float->int cast, truncated
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm(90): macro 'WAIT_US' called here
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm' included form here
00022c 2e30
00022d e007
00022e 943a
00022f f7f1
000230 943a
000231 950a
000232 f7d9                      	WAIT_US		(T1 - 4.5)
000233 951a
000234 f771                      	DJNZ		_w,data			
000235 940c 0241                 	jmp			next_b	
                                 			
                                 rdz_d:	
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm(221): warning: float->int cast, truncated
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm(95): macro 'WAIT_US' called here
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm' included form here
000237 e402
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\macros.asm(223): warning: float->int cast, truncated
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm(95): macro 'WAIT_US' called here
C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\main.asm(34): 'C:\Users\Hp\Documents\Atmel Studio\7.0\Sensor_tests\Sensor_tests\input_drivers.asm' included form here
000238 2e30
000239 e00d
00023a 943a
00023b f7f1
00023c 943a
00023d 950a
00023e f7d9                      	WAIT_US		(2*T1 - 5.5)
00023f 951a
000240 f711                      	DJNZ		_w,data				
                                 
                                 next_b:
000241 2ee4
000242 2ef5                      	MOV2		d3,d2,a3, a2	; store current command
                                 
                                 data_proc01:					; detect repeated code
000243 ef0f
000244 16f0                      	_CPI			d3, 0xff
000245 f471                      	brne		data_proc02
000246 ef0f
000247 16e0                      	_CPI			d2, 0xff
000248 f459                      	brne		data_proc02
000249 ef0f
00024a 16d0                      	_CPI			d1, 0xff 
00024b f441                      	brne		data_proc02
00024c ef0f
00024d 16c0                      	_CPI			d0, 0xff
00024e f429                      	brne		data_proc02 
                                 
                                 display_repeat:
00024f 2d48
000250 2d59
000251 2d2a
000252 2d3b                      	MOV4		a1,a0,a3,a2,c3,c2,c1,c0		; display the last correct code, i.e,
000253 c038                      	rjmp		data_recover
                                 
                                 data_proc02:								; detect transmission error
000254 94d0                      	com			d1
000255 10cd                      	cpse		d0, d1
000256 f5a9                      	brne		data_recover
000257 94f0                      	com			d3
000258 10ef                      	cpse		d2, d3
000259 f591                      	brne		data_recover
                                 
                                 display_correct:	
00025a 9540                      	com			a2							; complement b0 (chip delivers the complement)
00025b 9550                      	com			a3
00025c 9520                      	com			a0
00025d 9530                      	com			a1
00025e 931f
00025f ef0f
000260 e010
000261 1721
000262 0730
000263 911f                      	CPI2		a1, a0, 0xff00			;check if correct address
000264 f531                      	brne		end_display
                                 	;check each direction value individually
000265 931f
000266 e30d
000267 ec12
000268 1741
000269 0750
00026a 911f                      	CPI2		a3, a2, 0x3dc2
00026b f411                      	brne		PC+3
00026c e060                      	ldi			b0, 0
00026d c019                      	rjmp		store_correct
00026e 931f
00026f e90d
000270 e612
000271 1741
000272 0750
000273 911f                      	CPI2		a3, a2, 0x9d62
000274 f411                      	brne		PC+3
000275 e061                      	ldi			b0, 1
000276 c010                      	rjmp		store_correct
000277 931f
000278 ed0d
000279 e212
00027a 1741
00027b 0750
00027c 911f                      	CPI2		a3, a2, 0xdd22
00027d f411                      	brne		PC+3
00027e e062                      	ldi			b0, 2
00027f c007                      	rjmp		store_correct
000280 931f
000281 e507
000282 ea18
000283 1741
000284 0750
000285 911f                      	CPI2		a3, a2, 0x57a8
000286 e063                      	ldi			b0, 3
                                 	store_correct:
000287 2e84
000288 2e95
000289 2ea2
00028a 2eb3                      	MOV4		c3,c2,c1,c0,a1,a0,a3,a2		; storing correct code to display/use in 
                                 	end_display:
00028b c000                      	rjmp		data_recover
                                 	
                                 
                                 data_recover:
00028c 90ff
00028d 90ef
00028e 90df
00028f 90cf                      	POP4		d0, d1, d2, d3
000290 915f
000291 914f
000292 913f
000293 912f                      	POP4		a0, a1, a2, a3
                                 .include "snake_logic.asm"		;game logic code
000294 9508                      
                                  * main_snake.asm
                                  *
                                  *  Created: 03/05/2022 20:30:20
                                  *   Author: Elio Wanner and Axel Barbelanne
                                  */ 
                                 
                                 game_over:
000295 e0e0                      	ldi zl,low(0x0400)
000296 e0f4                      	ldi zh,high(0x0400)
000297 e420                      	ldi a0, 64
                                 
                                 game_over_loop:
000298 e000
000299 9301
00029a e00a
00029b 9301
00029c e000
00029d 9301                      	load_led_value_i 10,0,0		;show red screen to show failure (R=10)
00029e 952a                      	dec		a0
00029f f7c1                      	brne	game_over_loop
0002a0 e0e0                      	ldi		zl,low(0x0400)
0002a1 e0f4                      	ldi		zh,high(0x0400)
0002a2 d00c                      	rcall	show_on_matrix		;actually load red pixels on matrix
0002a3 6150                      	sbr		a3, (1 << 4)
                                 
0002a4 9508                      	ret
                                 
                                 ;SUBROUTINES---------------------------------------------------------------------
                                 
                                 ;set all LEDs to OFF
                                 reset_all_LEDs:
0002a5 e0e0                      	ldi		zl,low(0x0400)		;Where display starts
0002a6 e0f4                      	ldi		zh,high(0x0400)
0002a7 ec20                      	ldi		a0, 192				;3*64 (3 colours, 64 pixels)
                                 reset_ram_internal:
0002a8 e000                      	ldi		w, 0x00				;write a 0 to turn LED off
0002a9 9301                      	st		z+,w
0002aa 952a                      	dec		a0
0002ab f7e1                      	brne	reset_ram_internal	;loop until all off
0002ac e0e0                      	ldi		zl,low(0x0400)		;reset z to display start
0002ad e0f4                      	ldi		zh,high(0x0400)
0002ae 9508                      ret
                                 
                                 ;show what is stored in the SRAM at 0x0400 + 64
                                 show_on_matrix:
0002af e0e0                      	ldi		zl,low(0x0400)
0002b0 e0f4                      	ldi		zh,high(0x0400)
0002b1 e400
0002b2 2e00                      	_LDI	r0,64
                                 show_on_matrix_loop:
0002b3 9121                      	ld		a0, z+		;load values into a0,a1,a2 
0002b4 9131                      	ld		a1, z+		;because that is what the matrix driver will output
0002b5 9141                      	ld		a2, z+
                                 
0002b6 94f8                      	cli
0002b7 ded0                      	rcall	ws2812b4_byte3wr	;output the values to display
0002b8 9478                      	sei
                                 
0002b9 940a                      	dec		r0
0002ba f7c1                      	brne	show_on_matrix_loop
0002bb e0e0                      	ldi		zl,low(0x0400)		;reset z pointer
0002bc e0f4                      	ldi		zh,high(0x0400)
0002bd 9508                      ret
                                 
                                 ;Shows the length of the snake (score) on the LCD
                                 showScore:
0002be eca1
0002bf e0b4
0002c0 2799
0002c1 910d
0002c2 3f0f
0002c3 f011
0002c4 9593
0002c5 cffb
0002c6 959a                      	loadSnakeLength			;b3=snake length
                                 
0002c7 eca8                      	ldi		xl, low(200)
0002c8 e0b0                      	ldi		xh, high(200)
0002c9 2722                      	clr		a0
0002ca d105                      	rcall	eeprom_load			;loads highscore to a0
                                 
0002cb 1729                      	cp		a0, b3				
0002cc f420                      	brsh	showScore_showNow	;if lower --> don't change highscores
0002cd 2f29                      	mov		a0, b3
0002ce eca8                      	ldi		xl, low(200)
0002cf e0b0                      	ldi		xh, high(200)
0002d0 d0f1                      	rcall	eeprom_store		;store new highscore in eeprom
                                 	
                                 showScore_showNow:
0002d1 dd70                      	rcall	LCD_clear		;Clear LCD display
0002d2 dd71                      	rcall	LCD_home
0002d3 e306
0002d4 2e40
0002d5 e000
0002d6 2e50
0002d7 dd9c                      	PRINTF	LCD				;call display
0002d8 6353
0002d9 726f
0002da 3d65
0002db 19c0
0002dc 480a
0002dd 6769
0002de 7368
0002df 6f63
0002e0 6572
0002e1 c03d
0002e2 0012                      	.db		"Score=",FDEC,b+3, LF,"Highscore=",FDEC, a ,0	;Show Score on the first line and highscore on the second line
                                 	
0002e3 9508                      ret
                                 
                                 ;This sets the SnakeUnit in SRAM to 0xff
                                 setupSnake:
0002e4 eca2                      	ldi	xl,low(0x04C2)		;where Snake starts
0002e5 e0b4                      	ldi	xh,high(0x04C2)
0002e6 e420                      	ldi a0, 64
                                 setupSnake_internal:
0002e7 ef0f                      	ldi	w, 0xff				;set ram in SnakeUnit to 0xff (to indicate the absence of a snake part)
0002e8 930d                      	st	x+, w
0002e9 952a                      	dec a0
0002ea f7e1                      	brne setupSnake_internal
                                 
                                 	;INITIAL SNAKE
0002eb eca2                      	ldi	xl,low(0x04C2)		;where Snake is
0002ec e0b4                      	ldi	xh,high(0x04C2)
0002ed e203                      	ldi	w, 0x23				;initial length = 3 at the positions 0x23, 0x24, 0x25
0002ee 930d                      	st	x+, w
0002ef e204                      	ldi	w, 0x24
0002f0 930d                      	st	x+, w
0002f1 e205                      	ldi	w, 0x25
0002f2 930d                      	st	x+, w
                                 
0002f3 e060                      	ldi		b0, 0			;initial direction
0002f4 9508                      ret
                                 
                                 setupApple:
0002f5 eca1                      	ldi	xl,low(0x04C1)		;where Snake is
0002f6 e0b4                      	ldi	xh,high(0x04C1)
0002f7 e200                      	ldi	w, 0x20				;first apple location
0002f8 930d                      	st	x+, w
0002f9 9508                      ret
                                 
                                 ;Loads snake from snake storage in SRAM into the display (also in SRAM)
                                 ;z points to the place where it will be stored
                                 ;x points to the original place of the snake
                                 loadSnakeToDisplay:
0002fa e0e0                      	ldi		zl,low(0x0400)		;where Display is
0002fb e0f4                      	ldi		zh,high(0x0400)
                                 
0002fc eca2                      	ldi		xl,low(0x04C2)		;where Snake is
0002fd e0b4                      	ldi		xh,high(0x04C2)
                                 
0002fe dfa6                      	rcall	reset_all_LEDs		;first reset display to all OFF
0002ff e020                      	ldi		a0,0				;define head colour (G=40)
000300 e238                      	ldi		a1,40
000301 e040                      	ldi		a2,0
                                 loopThroughSnake:
000302 910d                      	ld		w, x+
                                 
000303 e0e0                      	ldi		zl,low(0x0400)		;where Display is
000304 e0f4                      	ldi		zh,high(0x0400)
                                 	
                                 	;add thrice, because for each colour
000305 0fe0
000306 f408
000307 5fff                      	ADDZ	w
000308 0fe0
000309 f408
00030a 5fff                      	ADDZ	w
00030b 0fe0
00030c f408
00030d 5fff                      	ADDZ	w
                                 
00030e 9331
00030f 9321
000310 9341                      	load_led_value a0,a1,a2		;COLOUR OF THE SNAKE
                                 
000311 2333                      	tst		a1					;Stop colour change if fully blue
000312 f011                      	breq	PC+3
000313 5035                      	subi	a1, 5				;Gradually change colour to blue
000314 5f4b                      	ADDI	a2, 5
                                 
000315 910c                      	ld		w, x
000316 3f0f                      	cpi		w, 0xff				;if 0xff is found that means the snake is fully displayed
000317 f751                      	brne	loopThroughSnake
000318 9508                      ret
                                 
                                 loadAppleToDisplay:
000319 e0e0                      	ldi		zl,low(0x0400)		;where Display is
00031a e0f4                      	ldi		zh,high(0x0400)
                                 
00031b eca1                      	ldi		xl,low(0x04C1)		;where Apple is
00031c e0b4                      	ldi		xh,high(0x04C1)
                                 
00031d e322                      	ldi		a0,50				;Apple Colour
00031e e030                      	ldi		a1,0
00031f e040                      	ldi		a2,0
000320 910d                      	ld		w, x+
000321 0fe0
000322 f408
000323 5fff                      	ADDZ	w
000324 0fe0
000325 f408
000326 5fff                      	ADDZ	w
000327 0fe0
000328 f408
000329 5fff                      	ADDZ	w
00032a 9331
00032b 9321
00032c 9341                      	load_led_value a0,a1,a2
00032d 9508                      ret
                                 
                                 ;	-Advances snake into the direction of the directionByte
                                 ;	-Checks for self eating
                                 ;	-Loops the head around if snake surpassing field limit
                                 autoAdvanceSnake:
00032e e0e0                      	ldi		zl,low(0x0400)		;where Display is
00032f e0f4                      	ldi		zh,high(0x0400)
                                 
000330 eca2                      	ldi		xl,low(0x04C2)		;where Snake is
000331 e0b4                      	ldi		xh,high(0x04C2)
                                 
000332 ecc1                      	ldi		yl, low(0x04C1)		;where Apple is
000333 e0d4                      	ldi		yh, high(0x04C1)
                                 
                                 	;load new head
000334 912c                      	ld		a0, x					;store current head position in a0
000335 2f02
000336 3060
000337 f049
000338 3061
000339 f0e1
00033a 3062
00033b f179
00033c 3063
00033d f009
00033e c056
00033f 940c 0380
000341 950a
000342 2f30
000343 3f3f
000344 f071
000345 3037
000346 f061
000347 303f
000348 f051
000349 3137
00034a f041
00034b 313f
00034c f031
00034d 3237
00034e f021
00034f 323f
000350 f011
000351 3337
000352 f001
000353 f409
000354 5f08
000355 c03f
000356 5f08
000357 2f30
000358 3430
000359 f071
00035a 3431
00035b f061
00035c 3432
00035d f051
00035e 3433
00035f f041
000360 3434
000361 f031
000362 3435
000363 f021
000364 3436
000365 f011
000366 3437
000367 f001
000368 f409
000369 5400
00036a c02a
00036b 9503
00036c 2f30
00036d 3038
00036e f071
00036f 3130
000370 f061
000371 3138
000372 f051
000373 3230
000374 f041
000375 3238
000376 f031
000377 3330
000378 f021
000379 3338
00037a f011
00037b 3430
00037c f001
00037d f409
00037e 5008
00037f c015
000380 5008
000381 2f30
000382 3f3f
000383 f071
000384 3f3e
000385 f061
000386 3f3d
000387 f051
000388 3f3c
000389 f041
00038a 3f3b
00038b f031
00038c 3f3a
00038d f021
00038e 3f39
00038f f011
000390 3f38
000391 f001
000392 f409
000393 5c00
000394 c000                      	findNewHeadPosition		a0, b0	;calculate new head position and put in w
                                 
000395 eca2                      	ldi		xl,low(0x04C2)			;reset because checkSelfEating modifies it
000396 e0b4                      	ldi		xh,high(0x04C2)
000397 8148                      	ld		a2, y					;get apple position
000398 1704                      	cp		w, a2					;see if new head on apple
000399 f411                      	brne	PC+3					;if on apple
00039a e041                      	ldi		a2, 1					;	a2=1
00039b c001                      	rjmp	PC+2
00039c e040                      	ldi		a2,0					;else: a2=0
00039d 930d                      	st		x+, w					;	add new head
                                 
                                 autoAdvanceSnake_movingInternal:	;Shifts the snake in the memory
00039e 913c                      	ld		a1, x
00039f 932d                      	st		x+,a0
0003a0 3f3f                      	cpi		a1, 0xff
0003a1 f029                      	breq	autoAdvanceSnake_endMove
                                 
0003a2 912c                      	ld		a0, x
0003a3 933d                      	st		x+, a1
0003a4 3f2f                      	cpi		a0, 0xff
0003a5 f009                      	breq	autoAdvanceSnake_endMove
                                 
0003a6 cff7                      	rjmp	autoAdvanceSnake_movingInternal
                                 autoAdvanceSnake_endMove:
0003a7 3041                      	cpi		a2, 1		;if on apple, don't remove tail (meaning snake gets longer)
0003a8 f019                      	breq	autoAdvance_setNewApple
0003a9 ef0f                      	ldi		w, 0xff
0003aa 930e                      	st		-x, w		;removing tail
0003ab c009                      	rjmp	autoAdvance_dontSetNewApple		;only setNewApple when one is eaten
                                 autoAdvance_setNewApple:
0003ac 910e                      	ld		w, -x
0003ad eca1                      	ldi		xl,low(0x04C1)		;where apple is stored
0003ae e0b4                      	ldi		xh,high(0x04C1)
0003af 0f06                      	add		w, b0				;Do some pseudo random operations to randomize new apple position
0003b0 5f06                      	subi	w, -10
0003b1 330f                      	cpi		w, 63
0003b2 f008                      	brlo	PC+2				;check if apple is in range (not exceeding the display) --> jump
0003b3 e002                      	ldi		w, 2				;if out of bounds set apple to position 2
0003b4 930c                      	st		x, w
                                 autoAdvance_dontSetNewApple:
                                 
0003b5 eca2
0003b6 e0b4
0003b7 910d
0003b8 914d
0003b9 1704
0003ba f029
0003bb 3f4f
0003bc f7d9
0003bd eca2
0003be e0b4
0003bf c001
0003c0 ded4                      checkSelfEating					;check if the snake is eating itself --> game over
0003c1 9508                      ret
                                 
                                 .include "eeprom.asm"
                                 
                                 ; purpose library, internal EEPROM
                                 
                                 eeprom_store:
                                 ; in:	xh:xl 	EEPROM address
                                 ;	a0	EEPROM data byte to store
                                 
0003c2 99e1                      	sbic	EECR,EEWE	; skip if EEWE=0 (wait it EEWE=1)
0003c3 cffe                      	rjmp	PC-1		; jump back to previous address
0003c4 bbae                      	out	EEARL,xl		; load EEPROM address low	
0003c5 bbbf                      	out	EEARH,xh		; load EEPROM address high
0003c6 bb2d                      	out	EEDR,a0			; set EEPROM data register
0003c7 f01f                      	brie	eeprom_cli	; if I=1 then temporarily disable interrupts
0003c8 9ae2                      	sbi	EECR,EEMWE		; set EEPROM Master Write Enable
0003c9 9ae1                      	sbi	EECR,EEWE		; set EEPROM Write Enable
0003ca 9508                      	ret	
                                 eeprom_cli:
0003cb 94f8                      	cli					; disable interrupts
0003cc 9ae2                      	sbi	EECR,EEMWE		; set EEPROM Master Write Enable
0003cd 9ae1                      	sbi	EECR,EEWE		; set EEPROM Write Enable
0003ce 9478                      	sei					; enable interrupts
0003cf 9508                      	ret
                                 
                                 eeprom_load:
                                 ; in:	xh:xl 	EEPROM address
                                 ; out:	a0	EEPROM data byte to load
                                 
0003d0 99e1                      	sbic	EECR,EEWE	; skip if EEWE=0 (wait it EEWE=1)
0003d1 cffe                      	rjmp	PC-1		; jump back to previous address
0003d2 bbae                      	out	EEARL,xl	
0003d3 bbbf                      	out	EEARH,xh
0003d4 9ae0                      	sbi	EECR,EERE		; set EEPROM Read Enable
0003d5 b32d                      	in	a0,EEDR			; read data register of EEPROM
0003d6 9508                      
                                 .equ	TOGGLE_BIT = 0			;mode toggle
                                 .equ	ADC_RDY_BIT = 1		;ADC converter ready
                                 .equ	BTN_RDY_BIT = 2		;toggle button ready
                                 .equ	IR_RDY_BIT = 3			;IR sensor ready
                                 .equ	GO_STATE = 4			;game over state
                                 .equ	SPD_RDY_BIT = 5		;speed buttons ready
                                 
                                 .equ	TURN_R_VAL = 0x0320
                                 .equ	TURN_L_VAL = 0x0190
                                 .equ	TOO_FAR_VAL = 0x0070	;value too far => ignored
                                 .equ	DIST_PRESC = 3			
                                 .equ	DEF_SNAKE_TIMER = 200	; 1 => 7.8ms
                                 .equ	HIGH_SPD_LIM = 50
                                 .equ	LOW_SPD_LIM = 244
                                 
                                 ;delay times for IR protocol
                                 .equ	T2 = 15532		
                                 .equ	T1 = 1180
                                 
                                 ; === interrupt service routines ====
                                 ext_int0:	;reset
0003d7 7e5f                      	cbr			a3, (1 << GO_STATE)	;clear game over
0003d8 df0b                      	rcall		setupSnake
0003d9 df1b                      	rcall		setupApple
0003da ec78                      	ldi			b1,DEF_SNAKE_TIMER	;set default speed
0003db bf71                      	out			OCR0,b1	
0003dc 9518                      	reti
                                 
                                 ext_int1:	;toggle mode (IR sensor/distance sensor)
0003dd ff52                      	sbrs		a3,BTN_RDY_BIT			;debounce (check if button is ready)
0003de c00c                      	rjmp		ext_int1_end
0003df 7f5b                      	cbr			a3,(1 << BTN_RDY_BIT)	;button not ready until small delay
0003e0 e001
0003e1 2750                      	_EORI		a3, (1 << TOGGLE_BIT)	;invert toggle pin
0003e2 b719                      	in			_w, EIMSK				;toggle IR sensor interrupt
0003e3 e800
0003e4 2710                      	_EORI		_w, 0x80
0003e5 bf19                      	out			EIMSK, _w
0003e6 9bc0
0003e7 c002
0003e8 98c0
0003e9 c001
0003ea 9ac0                      	INVP		PORTB, 0				;toggle mode LED
                                 	ext_int1_end:
0003eb 9518                      	reti
                                 
                                 ext_int2:	;slow down snake
0003ec ff55                      	sbrs		a3,SPD_RDY_BIT			;debounce (check if button is ready)
0003ed c034                      	rjmp		ext_int2_end
0003ee 7d5f                      	cbr			a3,(1 << SPD_RDY_BIT)	;button not ready until small delay
0003ef 3f74
0003f0 f010
0003f1 ef74
0003f2 c001
0003f3 9573
0003f4 3f74
0003f5 f010
0003f6 ef74
0003f7 c001
0003f8 9573
0003f9 3f74
0003fa f010
0003fb ef74
0003fc c001
0003fd 9573
0003fe 3f74
0003ff f010
000400 ef74
000401 c001
000402 9573
000403 3f74
000404 f010
000405 ef74
000406 c001
000407 9573
000408 3f74
000409 f010
00040a ef74
00040b c001
00040c 9573
00040d 3f74
00040e f010
00040f ef74
000410 c001
000411 9573
000412 3f74
000413 f010
000414 ef74
000415 c001
000416 9573
000417 3f74
000418 f010
000419 ef74
00041a c001
00041b 9573
00041c 3f74
00041d f010
00041e ef74
00041f c001
000420 9573                      	INC_LIM10	b1, LOW_SPD_LIM			;increase by 10 with a limit (slow down snake)
000421 bf71                      	out			OCR0,b1
                                 	ext_int2_end:
000422 9518                      	reti
                                 
                                 ext_int3:	;speed up snake
000423 ff55                      	sbrs		a3,SPD_RDY_BIT		;debounce (check if button is ready)
000424 c03e                      	rjmp		ext_int3_end
000425 7d5f                      	cbr			a3,(1 << SPD_RDY_BIT)		;button not ready until small delay
000426 3372
000427 f021
000428 f010
000429 957a
00042a c001
00042b e372
00042c 3372
00042d f021
00042e f010
00042f 957a
000430 c001
000431 e372
000432 3372
000433 f021
000434 f010
000435 957a
000436 c001
000437 e372
000438 3372
000439 f021
00043a f010
00043b 957a
00043c c001
00043d e372
00043e 3372
00043f f021
000440 f010
000441 957a
000442 c001
000443 e372
000444 3372
000445 f021
000446 f010
000447 957a
000448 c001
000449 e372
00044a 3372
00044b f021
00044c f010
00044d 957a
00044e c001
00044f e372
000450 3372
000451 f021
000452 f010
000453 957a
000454 c001
000455 e372
000456 3372
000457 f021
000458 f010
000459 957a
00045a c001
00045b e372
00045c 3372
00045d f021
00045e f010
00045f 957a
000460 c001
000461 e372                      	DEC_LIM10	b1, HIGH_SPD_LIM			;decrease by 10 with a limit (speed up snake)
000462 bf71                      	out			OCR0,b1
                                 	ext_int3_end:
000463 9518                      	reti
                                 
                                 ext_int7:	;IR sensor
000464 ff53                      	sbrs		a3,IR_RDY_BIT
000465 c00c                      	rjmp		end_interrupt
000466 7f57                      	cbr			a3, (1 << IR_RDY_BIT)
000467 ee04
000468 2e30
000469 e501
00046a 943a
00046b f7f1
00046c 943a
00046d 950a
00046e f7d9                      	WAIT_US		T2				; wait for timeout
00046f 9488                      	clc							; clearing carry
000470 dd7f                      	rcall		prep
000471 98c2                      	cbi			PORTB,2			;indicate received code
                                 	end_interrupt:
000472 9518                      	reti
                                 
                                 overflow2:	;counter for distance sensor measurement
000473 fd54                      	sbrc		a3, GO_STATE
000474 c002                      	rjmp		after_measure
000475 ff50                      	sbrs		a3, TOGGLE_BIT		;check toggle mode before measurement
000476 dd4c                      	rcall		measure
                                 	after_measure:	
000477 6250                      	sbr			a3, (1 << SPD_RDY_BIT)	;make speed changing buttons available again
000478 9518                      	reti
                                 
                                 output_compare0:	;counter for snake turns
000479 fd54                      	sbrc		a3, GO_STATE		;check game over state, skip if true
00047a c00e                      	rjmp		output_compare0_end
00047b ff50                      	sbrs		a3, TOGGLE_BIT		;check toggle
00047c dd4b                      	rcall		change_dir
00047d fd50                      	sbrc		a3, TOGGLE_BIT
00047e 9ac2                      	sbi			PORTB,2
00047f deae                      	rcall		autoAdvanceSnake		;move snake
000480 de79                      	rcall		loadSnakeToDisplay		;display snake
000481 de97                      	rcall		loadAppleToDisplay		;display apple
000482 fd54                      	sbrc		a3, GO_STATE			
000483 c005                      	rjmp		output_compare0_end		;end if game over
000484 de2a                      	rcall		show_on_matrix			;shows Display in SRAM to hardware
000485 dd33                      	rcall		ws2812b4_reset			;resets hardware-display
000486 de37                      	rcall		showScore				;show score on LCD screen
000487 6054                      	sbr			a3,(1 << BTN_RDY_BIT)	;Make buttons available again
000488 6058                      	sbr			a3, (1 << IR_RDY_BIT)
                                 	output_compare0_end:
000489 9518                      	reti
                                 	
                                 
                                 ADCCaddr_sra:
00048a 6052                      	sbr			a3,(1 << ADC_RDY_BIT)	;ADC data ready
00048b 9518                      	reti								
                                 
                                 ; === initialisation (reset) ===	
                                 reset: 
00048c ef0f
00048d bf0d
00048e e100
00048f bf0e                      	LDSP		RAMEND			; load stack pointer (SP)
000490 ef0f
000491 bb08                      	OUTI		PORTB,0xff		; turn LEDs off
000492 ef0f
000493 bb07                      	OUTI		DDRB,0xff		; LED's:output
000494 e70f
000495 b902                      	OUTI		DDRE,0x7f		; IR sensor input, ADC output
000496 ef0f
000497 bb0a                      	OUTI		DDRA, 0xff		;used by LCD
000498 ef0f
000499 bb04                      	OUTI		DDRC, 0xff		;used by LCD
00049a ef00
00049b bb01                      	OUTI		DDRD, 0b11110000;configure first two pins as inputs (for interrupt)
                                 								;pin7 is used for matrix LED
00049c e80f
00049d bf09                      	OUTI		EIMSK, 0x8f		;allow all interrupts at startup
00049e ea0a                      	ldi			w, 0b10101010
00049f 9300 006a                 	sts			EICRA, w		;detect on falling edge
0004a1 ec00                      	ldi			w, 0b11000000
0004a2 9300 003a                 	sts			EICRB, w		;detect on rising edge
                                 
0004a4 e008
0004a5 bf00                      	OUTI		ASSR, (1<<AS0)	; clock from TOSC1
0004a6 e005
0004a7 bd05                      	OUTI		TCCR2,5			; set prescaler
                                 	
0004a8 e00d
0004a9 bf03                      	OUTI		TCCR0,(1<<CTC0)+5	;clear on compare
0004aa ec78                      	ldi			b1, DEF_SNAKE_TIMER
0004ab bf71                      	out			OCR0,b1				;set snake speed
0004ac e402
0004ad bf07                      	OUTI		TIMSK,(1<<TOIE2) + (1<<OCIE0)
                                 	
0004ae e80e
0004af b906                      	OUTI		ADCSR,(1<<ADEN)+(1<<ADIE)+6 ; AD Enable, AD int. enable, PS=CK/64	
0004b0 e003
0004b1 b907                      	OUTI		ADMUX,3						; select channel POT
0004b2 7f5e                      	cbr			a3,ADC_RDY_BIT	
0004b3 7e5f                      	cbr			a3, (1 << GO_STATE)			;remomve game over state
0004b4 6058                      	sbr			a3, (1 << IR_RDY_BIT)		;make button available
0004b5 6051                      	sbr			a3,(1 << TOGGLE_BIT)		;default: remote
                                 
0004b6 db9f                      	rcall		LCD_init			; initialize the LCD
0004b7 dccf                      	rcall		ws2812b4_init
0004b8 de2b                      	rcall		setupSnake
0004b9 de3b                      	rcall		setupApple
                                 
0004ba eca8                      	ldi		xl, low(200)		;initializing highscore
0004bb e0b0                      	ldi		xh, high(200)
0004bc df13                      	rcall	eeprom_load
0004bd 3f2f                      	cpi		a0, 0xff			;on first boot up eeprom is 0xff, so need to clear it
0004be f411                      	brne	PC+3
0004bf 2722                      	clr		a0
0004c0 df01                      	rcall	eeprom_store		;loads highscore to a0
                                 
0004c1 9478                      	sei					; set global interrupt
                                 
                                 ; === main program ===
                                 main:
0004c2 cfff                      	rjmp		main


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :  26 y  :   1 z  :  13 r0 :   9 r1 :   0 r2 :   0 r3 :  26 r4 :   2 
r5 :   2 r6 :   0 r7 :   0 r8 :   7 r9 :   7 r10:   7 r11:   8 r12:  20 
r13:  10 r14:   5 r15:   6 r16: 222 r17:  46 r18:  57 r19:  72 r20:  49 
r21:  59 r22:  22 r23:  91 r24:   7 r25:  20 r26:  20 r27:  20 r28:   1 
r29:   1 r30:  27 r31:  22 
Registers used: 31 out of 35 (88.6%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  10 adiw  :   5 and   :   0 
andi  :   8 asr   :   2 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :   0 break :   0 breq  :  68 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   1 brlo  :  24 brlt  :   0 brmi  :   1 
brne  :  48 brpl  :   1 brsh  :   3 brtc  :   5 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   1 call  :   0 cbi   :  11 cbr   :   8 
clc   :   5 clh   :   0 cli   :   2 cln   :   0 clr   :  20 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  14 cp    :  16 cpc   :  11 
cpi   :  74 cpse  :   2 dec   :  47 elpm  :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :   5 inc   :  14 
jmp   :   8 ld    :  20 ldd   :   0 ldi   : 192 lds   :   3 lpm   :  12 
lsl   :   4 lsr   :   3 mov   :  49 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :  13 or    :   0 ori   :   2 out   :  29 
pop   :  39 push  :  38 rcall :  48 ret   :  30 reti  :   8 rjmp  :  95 
rol   :  14 ror   :  13 sbc   :   3 sbci  :   0 sbi   :  19 sbic  :   4 
sbis  :   3 sbiw  :   0 sbr   :   8 sbrc  :  20 sbrs  :   6 sec   :   2 
seh   :   0 sei   :   3 sen   :   0 ser   :   0 ses   :   0 set   :   1 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :  20 std   :   0 
sts   :   5 sub   :   6 subi  :  20 swap  :   4 tst   :   9 wdr   :   0 

Instructions used: 66 out of 114 (57.9%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000986   2358     22   2380  131072   1.8%
[.dseg] 0x000100 0x000100      0      0      0    4096   0.0%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 8 warnings
